# **1. Теория - JavaScript в клиентской части веб-приложения: полный теоретический разбор**

## **1.1. Роль JavaScript в архитектуре клиент–сервер**

В данной информационной системе JavaScript выполняет функции:

* реализации **клиентской логики**;
* управления поведением HTML-элементов;
* асинхронного взаимодействия с сервером (REST API);
* управления состоянием интерфейса;
* реализации бизнес-правил на стороне клиента;
* повышения отзывчивости и UX без перезагрузки страницы.

JavaScript связывает:

> **HTML (структура) + CSS (оформление) + Backend API (данные)**
> в единое интерактивное приложение.

---

## **1.2. DOM как объектная модель HTML-документа**

### **1.2.1. Понятие DOM**

**DOM (Document Object Model)** — это объектное представление HTML-документа в памяти браузера.

Каждый HTML-элемент становится JavaScript-объектом, с которым можно:

* читать и изменять содержимое;
* управлять стилями и классами;
* подписываться на события;
* добавлять и удалять элементы.

---

### **1.2.2. Поиск элементов DOM**

В проекте применяются основные методы DOM API:

* `document.getElementById()` — доступ по `id`;
* `document.querySelector()` — первый элемент по CSS-селектору;
* `document.querySelectorAll()` — коллекция элементов;
* `document.createElement()` — динамическое создание узлов.

Теоретически это означает:

> JavaScript **не дублирует HTML**, а управляет уже существующей структурой.

---

## **1.3. Событийная модель JavaScript**

### **1.3.1. Принцип событий**

JavaScript в браузере работает **реактивно**: код выполняется в ответ на события:

* действия пользователя;
* события браузера;
* таймеры;
* сетевые ответы.

---

### **1.3.2. Обработчики событий**

Во всех файлах используется современный подход:

```js
element.addEventListener("event", handler)
```

Используемые события:

* `submit` — отправка формы;
* `click` — кнопки, пагинация, сохранение;
* `mouseenter` / `mouseleave` — управление слайдером;
* `touchstart` / `touchend` — мобильные устройства.

Теоретически:

* логика отделена от HTML;
* обработчики можно добавлять и удалять динамически;
* код легче поддерживать.

---

## **1.4. Работа с формами**

### **1.4.1. Отмена стандартного поведения**

Во всех формах применяется:

```js
event.preventDefault();
```

Это предотвращает:

* перезагрузку страницы;
* потерю состояния интерфейса;
* неконтролируемую отправку данных.

---

### **1.4.2. HTML5-валидация через JavaScript**

Используется метод:

```js
form.checkValidity()
```

Он учитывает:

* `required`;
* `minlength`;
* `pattern`;
* тип поля (`email`, `password`).

Теоретически:

> JavaScript **использует возможности HTML**, а не дублирует их вручную.

---

## **1.5. Работа со строками и нормализация данных**

Во всех обработчиках применяется:

* `trim()` — удаление пробелов;
* приведение типов (`Number()`, `String()`);
* проверки на пустые значения.

Это важно для:

* корректной передачи данных;
* предотвращения ошибок БД;
* единообразия контрактов API.

---

## **1.6. Асинхронность и Fetch API**

### **1.6.1. Асинхронная модель**

В проекте используется современный синтаксис:

```js
async / await
```

Преимущества:

* линейное чтение кода;
* отсутствие «callback-адов»;
* удобная обработка ошибок.

---

### **1.6.2. Fetch API**

`fetch()` используется для всех запросов к серверу:

* `POST` — регистрация, вход, заявки, отзывы;
* `GET` — получение списков;
* `PATCH` — изменение статуса заявки.

Общий паттерн:

1. отправка JSON;
2. ожидание ответа;
3. проверка `res.ok`;
4. чтение `res.json()`.

---

## **1.7. Обработка ошибок и устойчивость интерфейса**

Во всех запросах применяется:

```js
try { ... } catch { ... }
```

Ошибки обрабатываются на двух уровнях:

* **HTTP-уровень** (`res.ok`);
* **сетевой уровень** (отсутствие сервера).

Пользователь всегда получает сообщение:

* об ошибке;
* или об успешном действии.

---

## **1.8. Управление состоянием через localStorage**

### **1.8.1. Назначение localStorage**

`localStorage` используется как **клиентское хранилище состояния**:

* `user_id`;
* `role`.

Данные:

* сохраняются между перезагрузками страниц;
* доступны JavaScript-коду;
* не отправляются автоматически на сервер.

---

### **1.8.2. Использование состояния**

На основе `localStorage`:

* скрывается или показывается контент;
* определяется доступ к админ-панели;
* выполняется логика “авторизован / не авторизован”.

Теоретически это пример **client-side state management**.

---

## **1.9. Динамическое формирование HTML**

### **1.9.1. Таблицы и списки**

Таблицы заявок создаются динамически:

* очищение `tbody`;
* создание `<tr>`;
* заполнение через `innerHTML`.

Это позволяет:

* работать с любым объёмом данных;
* обновлять интерфейс без перезагрузки;
* реализовать фильтрацию и пагинацию.

---

### **1.9.2. Управление классами**

Используются методы:

* `classList.add()`;
* `classList.remove()`;
* `className = ...`.

Это применяется для:

* блокировки форм;
* отображения ошибок/успеха;
* управления анимациями.

---

## **1.10. Реализация бизнес-правил на клиенте**

В JavaScript реализованы бизнес-ограничения:

* отзыв доступен **только после завершения курса**;
* админ может менять только допустимые статусы;
* пагинация не выходит за границы страниц;
* фильтры комбинируются логически.

Теоретически:

> клиентская логика дополняет серверную, улучшая UX.

---

## **1.11. Фильтрация и пагинация данных**

В админ-панели используются:

* массивы (`allApps`, `filteredApps`);
* `filter()`;
* `slice()`.

Это позволяет:

* не запрашивать сервер при каждом действии;
* мгновенно реагировать на ввод пользователя;
* снижать нагрузку на backend.

---

## **1.12. Таймеры и интервалы**

В `slider.js` используется:

* `setInterval`;
* `clearInterval`.

Назначение:

* автоматическая смена слайдов;
* управление автопрокруткой;
* приостановка при взаимодействии пользователя.

---

## **1.13. Изоляция кода и IIFE**

`slider.js` оформлен как **самовызывающаяся функция**:

```js
(function () { ... })();
```

Теоретически это:

* защита глобальной области видимости;
* изоляция компонента;
* примитивная модульность без сборщиков.

---

## **1.14. Поддержка мобильных устройств**

JavaScript учитывает:

* touch-события;
* отсутствие hover на мобильных;
* пассивные слушатели (`{ passive: true }`).

Это повышает:

* производительность;
* корректность поведения на смартфонах.

---

## **1.15. Доступность (Accessibility)**

JavaScript взаимодействует с элементами, имеющими:

* `aria-label`;
* `aria-live="polite"`;
* `role="status"`.

Это обеспечивает:

* озвучивание изменений интерфейса;
* доступность для скринридеров;
* соответствие базовым требованиям WCAG.

---

## **1.16. Ограничения текущей реализации**

С точки зрения теории важно отметить:

* нет модульной системы (ES modules);
* нет централизованного state-manager;
* роль администратора проверяется в основном на клиенте;
* нет JWT / session-based auth.

Это **нормально для учебного проекта**, но должно быть осознано теоретически.

---

## **1.17. Итоговая роль JavaScript в проекте**

В данной системе JavaScript:

* реализует интерактивность;
* управляет формами и таблицами;
* обеспечивает связь с сервером;
* реализует бизнес-правила интерфейса;
* повышает удобство и отзывчивость ИС.

**Без JavaScript проект превратился бы в набор статических HTML-страниц.**
