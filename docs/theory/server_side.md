# 1. Теория - Серверная реализация на Flask: полный разбор по `app.py`

## 1.1. Состав модулей и назначение импортов

В файле используются несколько категорий библиотек:

* **Flask-слой**: `Flask`, `request`, `jsonify`, `send_from_directory` — создание приложения, чтение запросов, ответы JSON, отдача файлов фронтенда. 
* **Инфраструктура**: `os` — работа с путями и каталогами проекта. 
* **CORS**: `flask_cors.CORS` — разрешение браузерных запросов к API при разделении источников. 
* **Валидация**: `re` и регулярные выражения для проверки полей. 
* **База данных**: `pymysql` — подключение и запросы к MySQL. 
* **Безопасность паролей**: `hashlib` — вычисление SHA-256 для хранения пароля в виде хеша. 

Важно: в конце файла `hashlib` импортируется **повторно** и выполняется `print(...)` — это уже относится к отладочным остаткам (см. п. 1.11). 

---

## 1.2. Инициализация приложения и CORS

Создание приложения и включение CORS:

* `app = Flask(__name__)`
* `CORS(app)`

Теоретически это означает, что сервер:

* поднимает HTTP-приложение Flask;
* разрешает междоменные запросы (например, если фронтенд открыт не тем же доменом/портом). 

---

## 1.3. Конфигурация БД и принципы подключения

В `DB_CONFIG` заданы параметры MySQL (типично для XAMPP): хост, пользователь, база, кодировка, а также `cursorclass = DictCursor`. 

Теоретически это даёт:

* **управляемое подключение** через `pymysql.connect(**DB_CONFIG)`;
* возвращение строк результата как словарей (`{"id": ..., "name": ...}`), что удобно для `jsonify`;
* кодировка `utf8mb4` корректно хранит кириллицу и расширенные символы.

Функция `db_conn()` — инкапсуляция подключения, повышает сопровождаемость. 

---

## 1.4. Работа с путями проекта и раздача фронтенда

Файл задаёт базовые директории:

* `BASE_DIR = os.path.dirname(__file__)`
* `FRONTEND_DIR = os.path.join(BASE_DIR, "..", "frontend")` 

Это означает, что Flask выступает **не только как API**, но и как сервер статического фронтенда (HTML/CSS/JS/изображения).

---

## 1.5. Маршруты отдачи HTML и статических файлов

### 1.5.1. HTML-страницы

Эндпоинты:

* `/` → `login.html`
* `/login` → `login.html`
* `/register` → `register.html`
* `/applications` → `applications.html`
* `/create_application` → `create_application.html`
* `/admin` → `admin.html` 

Теоретически это “серверная навигация”: при открытии URL сервер возвращает соответствующий HTML.

### 1.5.2. CSS/JS/медиа

Эндпоинты:

* `/styles.css` → `styles.css`
* `/slider.js` → `slider.js`
* `/assets/<path:filepath>` → статические ресурсы из папки `assets/` 

Важно: **`/styles.css` определён дважды** (две разные функции `styles_css()` и `styles()`). В Flask повтор маршрута приводит к тому, что фактически будет работать **последняя объявленная** функция (или возможны предупреждения/конфликт в зависимости от версии). Это нужно учитывать как теоретический пример “коллизии маршрутов”. 

---

## 1.6. Регулярные выражения и контракт данных

В коде определены регулярные выражения:

* `RE_LOGIN = r"^[A-Za-z]{4,}$"` — только латинские буквы, минимум 4;
* `RE_FULL_NAME` — кириллица и пробелы;
* `RE_PHONE` — формат `8(XXX)XXX-XX-XX`;
* `RE_EMAIL` — упрощённая проверка email. 

Теоретически это реализация принципа:

> сервер обязан валидировать входные данные независимо от клиента.

При этом есть нюанс согласованности: в HTML у вас логин допускает **латиницу и цифры** (`^[A-Za-z0-9]{4,}$`), а сервер допускает только буквы (`^[A-Za-z]{4,}$`). Это пример расхождения “клиентского и серверного контракта”, из-за которого пользователь может пройти проверку формы, но получить отказ на сервере. 

---

## 1.7. Хеширование пароля и хранение учётных данных

Функция `hash_password()` возвращает SHA-256 от строки пароля. 

Теоретически:

* **пароль не хранится в исходном виде**;
* на входе и при проверке вычисляется хеш и сравнивается с БД.

Для production-практики обычно применяют `bcrypt/argon2` + соль, но для учебной работы демонстрация “хранить только хеш” является базовым минимумом.

---

## 1.8. Регистрация пользователя: структура обработчика

`POST /api/register` реализует полный сценарий:

1. чтение JSON (`request.get_json`)
2. нормализация данных (`strip`)
3. обязательность всех полей
4. проверки по regex и длине пароля
5. проверка уникальности логина/email
6. получение `role_id` для роли `user`
7. вставка в таблицу `users`
8. возврат 201 или кодов ошибок 400/409/500 

Теоретически это соответствует best practice:

* сначала валидация,
* затем запросы к БД,
* использование параметризованных запросов (`%s`) как защита от SQL-инъекций.

---

## 1.9. Авторизация: проверка пароля и выдача роли

`POST /api/login`:

* проверяет наличие логина/пароля;
* валидирует формат логина;
* получает пользователя и роль через `JOIN roles`;
* сравнивает хеши;
* возвращает `user_id` и `role`. 

Теоретически важно, что роль возвращается клиенту — это основа для UI-разграничения (“админка”/“пользователь”), но **сама по себе** эта роль на клиенте не является полноценной защитой (см. п. 1.12).

---

## 1.10. Работа со справочниками и связями в БД

В логике заявок и списков видно, что база данных нормализована и использует справочники:

* `payment_methods` (способ оплаты),
* `application_statuses` (статусы),
* `roles` (роли). 

Это теоретически важно как пример:

* хранить “значения перечислений” не строками в основной таблице, а через ссылки на справочники (ID);
* обеспечивать целостность и единообразие данных.

---

## 1.11. Получение заявок пользователя и форматирование дат

`GET /api/applications/my` принимает `user_id` через query string. 

Здесь важно:

* сервер проверяет, что `user_id` — число (`isdigit`);
* в SQL используется `DATE_FORMAT(...)` для выдачи дат сразу в строковом формате:

  * `start_date` в `YYYY-MM-DD`,
  * `created_at` в `YYYY-MM-DD HH:MM:SS`. 

Теоретически это демонстрирует подход:

* либо форматировать даты на сервере (как здесь),
* либо отдавать “сырые” даты и форматировать на клиенте.

---

## 1.12. Отзывы: минимальная серверная бизнес-логика

`POST /api/reviews`:

* проверяет `user_id` как `int`;
* требует непустой текст;
* проверяет существование пользователя перед вставкой;
* пишет в `reviews (user_id, text)` и возвращает 201. 

Теоретический смысл: защита от “висячих ссылок” (когда отзыв создаётся для несуществующего пользователя).

---

## 1.13. Создание заявки: преобразование бизнес-правил в проверки

`POST /api/applications`:

* проверяет `user_id`;
* требует `course_name`, `start_date`, `payment_method`;
* допускает **только два** способа оплаты (строгое перечисление);
* маппит `payment_method` → `payment_method_id`;
* устанавливает статус по умолчанию “Новая” через справочник;
* создаёт запись в `applications`. 

Теоретически это пример “сервер обеспечивает правила предметной области”, а не доверяет клиенту.

---

## 1.14. Админские операции: список и обновление статуса

### 1.14.1. Список всех заявок

`GET /api/admin/applications` возвращает таблицу заявок с привязкой логина пользователя, способа оплаты и статуса через JOIN. 

### 1.14.2. Обновление статуса

`PATCH /api/admin/applications/<app_id>/status`:

* принимает `status` из JSON,
* разрешает только `{"Идёт обучение", "Обучение завершено", "Новая"}`,
* получает `status_id` из справочника,
* обновляет строку `applications`,
* возвращает 200/400/404/500. 

Теоретически это корректный паттерн частичного обновления ресурса через PATCH.

---

## 1.15. Отладочные остатки и режим запуска

Внизу файла присутствует:

* повторный `import hashlib`;
* `print(hashlib.sha256("KorokNET"...))` — вывод хеша в консоль при старте;
* запуск `app.run(..., debug=True)`. 

Теоретически:

* `debug=True` удобен в разработке, но в production недопустим;
* печать хеша — признак тестирования/проверки (её обычно удаляют из финальной версии).

---

## 1.16. Важное ограничение текущей модели безопасности

В файле отсутствует серверная проверка “админ ли пользователь” для маршрутов `/api/admin/...`. Сейчас доступ к админ-эндпоинтам регулируется в основном клиентом (через `localStorage role`). 

Теоретически это важно сформулировать так:

* **клиентский контроль не является защитой**, потому что запрос можно отправить напрямую;
* корректная модель требует серверной авторизации (сессия/токен) и проверки роли на сервере.

 